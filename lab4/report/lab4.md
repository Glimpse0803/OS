# LAB4实验报告
## 练习三
### 代码实现
根据文档的提示与说明，我们参考schedule函数里面的禁止和启用中断的过程，编写代码如下：
```c
void proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        local_intr_save(intr_flag);
        {
            current = proc;
            lcr3(next->cr3);
            switch_to(&(prev->context), &(next->context));
        }
        local_intr_restore(intr_flag);
    }
}
```
此函数基本思路是:
- 让 current指向 next内核线程initproc;
- 设置 CR3 寄存器的值为 next 内核线程 initproc 的页目录表起始地址 next->cr3，这实际上是完成进程间的页表切换;
- 由 switch_to函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当switch_to 函数执行完“ret”指令后，就切换到initproc执行了。

值得注意的是，这里我们使用1oca1_intr_save()和1ocal_intr_restore()作用分别是屏蔽中断和打开中断，以免进程切换时其他进程再进行调度，保护进程切换不会被中断。

### 问题解答
在本实验中，创建且运行了2两个内核线程:
- idleproc : 第一个内核进程，完成内核中各个子系统的初始化，之后立即调度，执行其他进程。
- initproc : 用于完成实验的功能而调度的内核进程。

## 实验中的知识点
### 进程与线程的关系
我们平时编写的源代码，经过编译器编译就变成了可执行文件，我们管这一类文件叫做`程序`。而当一个程序被用户或操作系统启动，分配资源，装载进内存开始执行后，它就成为了一个`进程`。

进程与程序之间最大的不同在于`进程是一个“正在运行”的实体`，而`程序只是一个不动的文件`。进程包含程序的内容，也就是它的静态的代码部分，也包括一些在运行时在可以体现出来的信息，比如堆栈，寄存器等数据，这些组成了进程“正在运行"的特性。如果我们只关注于那些“正在运行”的部分，我们就从进程当中剥离出来了线程。

一个进程可以对应一个线程，也可以对应很多线程。这些线程之间往往具有相同的代码，共享一块内存，但是却有不同的CPU执行状态。相比于线程，进程更多的作为一个资源管理的实体(因为操作系统分配网络等资源时往往是基于进程的)，这样线程就作为可以被调度的最小单元，给了调度器更多的调度可能。

### 进程调度
上OS课时候宫老师提到过，调度的代价是很大的，其中一般涉及：
- 减少上下文切换涉及的寄存器数量
- 减少不必要的权限切换

一些理论上可以处理的方式包括：
- 纤程 Fiber, ucontext
- 协程 coroutine
- 发挥ULT快速切换的优势
- 在编程时提出对程序员的限制，要求他们妥善的设计代码