# Lab 4 实验报告
## 练习1：分配并初始化一个进程控制块（需要编码）
>alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
>
>请在实验报告中简要说明你的设计实现过程。请回答如下问题：
>
>请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）
>

### (一)设计实现过程
补充的代码如下：
```c
     proc->state = PROC_UNINIT;
     proc->pid = -1; 
     proc->runs = 0;  
     proc->kstack = 0;
     proc->need_resched = 0;
     proc->parent = NULL;
     proc->mm = NULL;
     memset(&(proc->context), 0, sizeof(struct context));
     proc->tf = NULL;
     proc->cr3 = boot_cr3;
     proc->flags = 0;
     memset(proc->name, 0, PROC_NAME_LEN);

```

详细实现过程如下：

1.**` proc->state = PROC_UNINIT`**
- **代码作用**
   - 将进程的初始状态设置为 `PROC_UNINIT`，即设置进程为“初始”态，表示该进程尚未完成初始化。  
- **详细说明**：
     - state是进程所处的状态。ucore中进程状态有四种：分别是PROC_UNINIT、PROC_SLEEPING、PROC_RUNNABLE、PROC_ZOMBIE。通过将状态设为 `PROC_UNINIT`，我们可以明确标记该进程目前尚未完成配置或分配，防止后续被错误调度或访问。
     - 这是一个安全性措施，确保进程在完成关键资源配置（如内存、栈、页表等）之前不会参与调度。
  


- **PROC_UNINIT**（未初始化状态）：
  - 进程控制块在刚被分配但尚未完成初始化时所处的状态。
  - 在此状态下，进程还未准备好执行，通常需要完成一系列初始化操作，如分配资源、设置初始参数等。
  - 在alloc_proc函数中分配进程时所处的状态。


- **PROC_SLEEPING**（睡眠状态）：
  - 进程因等待某个事件（如I/O操作完成、信号量释放等）而无法继续执行时所处的状态。
  - 在此状态下，进程不占用CPU资源，但会保留其上下文信息，以便在事件发生时能够恢复执行。
  - 它允许操作系统在进程等待期间将CPU资源分配给其他进程。
  - try_free_pages、do_wait、do_sleep等函数中，进程因等待资源或事件而进入睡眠状态。

- **PROC_RUNNABLE**（可运行状态）：
  - 进程已完成初始化并准备好执行，且当前未被调度执行时所处的状态。
  - 在此状态下，进程已经具备执行条件，但可能由于调度策略或其他进程正在执行而暂时无法获得CPU资源。
  - 可运行状态是进程进入执行状态前的必要准备阶段，也是进程调度器在选择执行进程时的主要考虑对象。
  - 在proc_init、wakeup_proc等函数中，进程被初始化或唤醒后，进入可运行状态，准备被调度执行。

- **PROC_ZOMBIE**（僵尸状态）：
  - 进程已执行完毕并退出，但其进程控制块和相关资源尚未被操作系统回收时所处的状态。
  - 在此状态下，进程本身已不再执行任何代码，但其相关信息（如退出状态码、资源使用情况等）仍保留在进程控制块中，以供父进程查询或回收。
  - 僵尸状态是进程生命周期的最后阶段之一，它允许父进程在需要时获取子进程的退出信息并释放相关资源。
  - 在do_exit函数中，进程执行完毕后，进入僵尸状态，等待父进程回收其资源。

- **进程状态转换：**
  - 通过alloc_proc函数分配的进程最初处于PROC_UNINIT状态，通过proc_init或wakeup_proc函数初始化或唤醒后，进入PROC_RUNNABLE状态。
  - 在try_free_pages、do_wait、do_sleep等函数中，进程可能因等待资源或事件而进入PROC_SLEEPING状态。
  - 在do_exit函数中，进程执行完毕后进入PROC_ZOMBIE状态。
  - 通过wakeup_proc函数可以唤醒处于PROC_SLEEPING状态的进程，使其重新进入PROC_RUNNABLE状态。






2. **`proc->pid = -1;`**
   - **作用**：初始化进程的 `pid` 字段为 `-1`，表明该进程尚未被分配唯一标识符（PID）。
   - **详细说明**：
     - 每个进程在系统中需要一个唯一的进程 ID，用于区分不同进程。
     - 设置为 `-1` 是一个约定俗成的占位值，表示该字段尚未有效。
     - 在后续的进程管理过程中，将通过 PID 分配器为该进程生成一个有效的PID。



3. **`proc->runs = 0;`**
   - **作用**：将 `runs` 字段初始化为 `0`，记录该进程的运行次数。
   - **详细说明**：
     - `runs` 是一个计数器，用于跟踪进程被调度到 CPU 上运行的次数。这对于调试和性能监控非常有用。
     - 将初始值设为 `0`，表明进程还未获得过 CPU 时间。
     - 未来，当调度器将该进程加载到 CPU 时，此计数器会递增。



4. **`proc->kstack = 0;`**
   - **作用**：初始化进程的内核栈地址为 `0`。
   - **详细说明**：
     -  每个线程都有一个内核栈，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时的程序使用的栈；而对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈。
     - 此处将 `kstack` 设置为 `0`，表明栈尚未分配地址，避免误用无效地址。
     - 在后续代码中，内核会通过专门的栈分配器为该字段分配实际的栈空间。
     - kstack记录了分配给该进程/线程的内核栈的位置。主要作用有以下几点。
       - 首先，当内核准备从一个进程切换到另一个的时候，需要根据kstack 的值正确的设置好 tss，以便在进程切换以后再发生中断时能够使用正确的栈。
       - 其次，内核栈位于内核地址空间，并且是不共享的（每个线程都拥有自己的内核栈），因此不受到 mm 的管理，当进程退出的时候，内核能够根据 kstack 的值快速定位栈的位置并进行回收。



5. **`proc->need_resched = 0;`**
   - **作用**：将 `need_resched` 字段设置为 `0`，表示该进程目前不需要被重新调度。
   - **详细说明**：
     - 调度器通过该标志决定是否需要抢占当前进程并将 CPU 时间片交给其他进程。
     - 初始化为 `0` 表明该进程不主动请求调度，可以正常运行。


6. **`proc->parent = NULL;`**
   - **作用**：将 `parent` 字段设置为 `NULL`，表示该进程尚无父进程。
   - **详细说明**：
     - 系统中的进程通常是通过 `fork` 系统调用从父进程派生的，因此每个进程都有一个父进程。
     - 此处设置为 `NULL`，是为独立创建的进程或系统进程准备的，表明尚未建立父子关系。
     - parent里面保存了进程的父进程的指针。在内核中，只有内核创建的idle进程没有父进程，其他进程都有父进程。进程的父子关系组成了一棵进程树，这种父子关系有利于维护父进程对于子进程的一些特殊操作。



7. **`proc->mm = NULL;`**
   - **作用**：将 `mm` 字段设置为 `NULL`，表示该进程还未分配内存管理结构。
   - **详细说明**：
     - `mm` 指向进程的内存管理信息，里面保存了内存管理的信息，包括内存映射，虚存管理等内容。
     - 初始化为 `NULL`，避免误用未分配的内存管理结构。
     - 在分配内存资源时会填充该字段。
     



8. **`memset(&(proc->context), 0, sizeof(struct context));`**
   - **作用**：将 `context` 字段清零，初始化进程的上下文切换结构。
   - **详细说明**：
     - `context` 保存了进程执行的上下文，也就是几个关键的寄存器的值。这些寄存器的值用于在进程切换中还原之前进程的运行状态。切换过程的实现在kern/process/switch.S。context中保存了进程执行的上下文，也就是几个关键的寄存器的值。这些寄存器的值用于在进程切换中还原之前进程的运行状态（进程切换的详细过程在后面会介绍）。切换过程的实现在kern/process/switch.S。
     - 使用 `memset` 将结构体清零，确保所有寄存器初始状态一致，避免加载随机值。
     -



9. **`proc->tf = NULL;`**
   - **作用**：初始化 `tf` 字段为 `NULL`，表示该进程没有可用的中断上下文。
   - **详细说明**：
     - tf里保存了进程的中断帧。当进程从用户空间跳进内核空间的时候，进程的执行状态被保存在了中断帧中。
     - 系统调用可能会改变用户寄存器的值，我们可以通过调整中断帧来使得系统调用返回特定的值。
     - 将其设置为 `NULL`，表明该进程尚未进入内核态，也未处理中断或系统调用。
    



10. **`proc->cr3 = boot_cr3;`**
    - **作用**：将 `cr3` 字段初始化为 `boot_cr3`，即系统初始化时的页目录基地址，使用内核页目录表的基址。
    - **详细说明**：
      - cr3寄存器是x86架构的特殊寄存器，用来保存页表所在的基址。
      - 由于该内核线程在内核中运行，故采用为uCore内核已经建立的页表，即设置为在uCore内核页表的起始地址boot_cr3。
      - 所有内核线程的内核虚地址空间（也包括物理地址空间）是相同的。
      



11. **`proc->flags = 0;`**
    - **作用**：将 `flags` 字段设置为 `0`，表示进程没有任何特殊标志。
    - **详细说明**：
      - `flags` 是一个位掩码，记录进程的特定状态或行为标志。
      - 初始化为 `0`，表明进程处于普通状态。



12. **`memset(proc->name, 0, PROC_NAME_LEN);`**
    - **作用**：将 `name` 字段清零，初始化进程名称为空字符串。
    - **详细说明**：
      - `name` 是进程名，用于调试和管理。
      - 使用 `memset` 清零可以确保名称字符串以空字符结尾，防止读取无效数据。






### (二)   struct context context变量含义和在本实验中的作用

struct context定义如下：
```c
struct context {
    uintptr_t ra;
    uintptr_t sp;
    uintptr_t s0;
    uintptr_t s1;
    uintptr_t s2;
    uintptr_t s3;
    uintptr_t s4;
    uintptr_t s5;
    uintptr_t s6;
    uintptr_t s7;
    uintptr_t s8;
    uintptr_t s9;
    uintptr_t s10;
    uintptr_t s11;
};
```


#### 变量含义：
- **`context`** 结构体保存的是 **进程上下文**（即进程切换时的 CPU 寄存器状态）。
  - 它用于在进程切换时保存和恢复某些关键寄存器的值，使得进程可以从暂停的位置继续执行。
  - 切换过程的实现在kern/process/switch.S。
- 其中包含了ra，sp，s0~s11共14个寄存器。
  - `ra`：保存返回地址寄存器，用于函数返回。
  - `sp`：保存堆栈指针寄存器（stack pointer），用于指向进程的栈顶。
  - `s0` 至 `s11`：保存通用寄存器。
  - 寄存器可以分为调用者保存（caller-saved）寄存器和被调用者保存（callee-saved）寄存器。
    - 因为线程切换在一个函数当中，所以编译器会**自动帮助我们生成保存和恢复调用者保存寄存器的代码。**
    - 在实际的进程切换过程中我们**只需要保存被调用者保存寄存器！**



#### 在实验中的作用：
1. **进程上下文切换：**
   - 当内核切换当前运行的进程时，需要保存当前进程的运行状态（包括寄存器值）。
   - 切换到下一个进程时，将下一个进程的上下文加载到 CPU 寄存器中，继续执行。

2. **保存和恢复现场：**
   - `context` 中保存的值可以确保当一个进程重新获得 CPU 时，能够恢复到被中断前的运行状态。


### (三) struct trapframe *tf变量含义和在本实验中的作用

struct trapframe定义如下：

```c

struct trapframe {
    struct pushregs gpr;
    uintptr_t status;
    uintptr_t epc;
    uintptr_t badvaddr;
    uintptr_t cause;
};
```
#### 变量含义：
- **`trapframe`** 结构体保存的是 **中断/异常发生时的 CPU 状态**，包括通用寄存器、异常原因、异常发生地址等。
  - **`gpr`**：保存通用寄存器的值。
  - **`status`**：保存处理器状态寄存器（`sstatus`），包含全局中断使能位等信息。
  - **`epc`**：保存异常程序计数器，即引发异常的指令地址。
  - **`badvaddr`**：保存引发异常的虚拟地址。
  - **`cause`**：保存引发异常的原因。
- 它通常用于处理中断、系统调用或其他异常情况。

- tf里**保存了进程的中断帧**。当进程从用户空间跳进内核空间的时候，**进程的执行状态被保存在了中断帧中**。
  - 系统调用可能会改变用户寄存器的值，我们可以通过**调整中断帧来使得系统调用返回特定的值。**


#### 在实验中的作用：
1. **处理中断和系统调用：**
   - 当 CPU 遇到中断或异常时，当前的寄存器状态会被保存到 `trapframe` 中。
   - 内核通过访问 `trapframe`，可以获取异常的上下文信息，例如异常地址和原因。

2. **用户态到内核态切换：**
   - 在系统调用或中断时，`trapframe` 保存用户态寄存器的值，内核完成处理后会根据 `trapframe` 恢复用户态状态并返回。

3. **异常处理：**
   - 如果进程在执行过程中发生非法操作（例如访问非法地址），`trapframe` 中的 `badvaddr` 和 `cause` 字段可以帮助内核识别和处理该异常。



#### **总结：两者在本实验中的作用**
1. **`context`**：
   - 用于进程切换时保存和恢复进程的运行状态。

2. **`tf`**：
   - 用于处理中断或异常时保存进程状态。
   - 提供异常上下文信息，协助内核进行中断和异常处理。
   - 主要作用于中断处理和系统调用过程。

# LAB4实验报告

## 练习2：为新创建的内核线程分配资源（需要编码）

> 创建一个内核线程需要分配和设置好很多资源。`kernel_thread`函数通过调用`do_fork`函数完成具体内核线程的创建工作。`do_kernel`函数会调用`alloc_proc`函数来分配并初始化一个进程控制块，但`alloc_proc`只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过`do_fork`实际创建新的内核线程。`do_fork`的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。因此，我们实际需要`fork`的东西就是`stack`和`trapframe`。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在`kern/process/proc.c`中的`do_fork`函数中的处理过程。它的大致执行步骤包括：
>
> - 调用`alloc_proc`，首先获得一块用户信息块。
> - 为进程分配一个内核栈。
> - 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
> - 复制原进程上下文到新进程
> - 将新进程添加到进程列表
> - 唤醒新进程
> - 返回新进程号
>
> 请在实验报告中简要说明你的设计实现过程。请回答如下问题：
>
> - 请说明ucore是否做到给每个新`fork`的线程一个唯一的`id`？请说明你的分析和理由。

### 函数设计实现

根据指导书中给出的执行步骤，实现步骤如下：

1. 调用`alloc_proc`函数，分配并初始化进程控制块；主要工作是通过`kmalloc`函数获得`proc_struct`结构的一块内存块，并把`proc`进行初步初始化。如果没有成功，跳转至`fork_out`处做对应的出错处理。

   ```c
   proc = alloc_proc(); // 分配并初始化进程控制块
   if (proc == NULL)
   {
       goto fork_out;
   }
   ```

2. 调用`setup_kstack`函数，分配并初始化内核栈。主要工作是调用 `alloc_pages` 函数来分配指定大小的页面，然后将分配的页面的虚拟地址赋给进程的 `kstack` 字段，表示该页面是进程的内核栈。如果分配成功，函数返回0表示成功，否则返回错误码 -E_NO_MEM 表示内存不足。如果内存不足，跳转至`bad_fork_cleanup_kstack`处做对应的出错处理。

   ```c
   ret = setup_kstack(proc); // 分配并初始化内核栈
   if (ret == -E_NO_MEM)
   {
       goto bad_fork_cleanup_kstack;
   }
   ```

3. 调用`copy_mm`函数，根据`clone_flags`决定是复制还是共享内存管理系统。由于目前在实验四中只能创建内核线程，所以`copy_mm`中不执行任何操作。

   ```c
   copy_mm(clone_flags, proc);
   ```

4. 调用`copy_thread`函数设置进程的中断帧和上下文。

   ```c
   copy_thread(proc, stack, tf);
   ```

5. 调用`get_pid`函数，为新进程分配PID。

   ```c
   const int pid = get_pid();
   proc->pid = pid;
   ```

6. 把设置好的进程加入进程链表，计算PID哈希值并加入到对应的哈希表。

   ```c
   list_add(hash_list + pid_hashfn(pid), &(proc->hash_link));
   list_add(&proc_list, &(proc->list_link));
   ```

7. 调用`wakeup_pro`函数，将新建的进程设为就绪态。

   ```c
   wakeup_proc(proc);
   ```

8. 总进程数加1。

   ```c
   nr_process++;
   ```

9. 将返回值设为线程id。

   ```c
   ret = pid;
   ```

### 问题回答

> 请说明ucore是否做到给每个新`fork`的线程一个唯一的`id`？请说明你的分析和理由。

ucore调用`get_pid`函数，为每个新线程分配PID，而分析`get_pid`的实现可知，它会返回一个唯一的未被使用的PID。

`get_pid`函数的基本思想是遍历进程列表，在遍历时维护一个区间`[last_pid,next_safe)`，一直保证此区间内始终为未使用的PID。具体方法如下：


- 首次调用时初始化**静态变量**`last_pid`与`next_safe`为最大PID`MAX_PID`，之后的调用会保留上一次调用结束时的值，之后每次调用时`last_pid`的意义是上次分配的PID。
- 如果`++last_pid`小于`next_safe`，直接分配`last_pid`；
- 如果`last_pid`大于等于`MAX_PID`，超出范围了，将`last_pid`重置为1；
- 如果`last_pid`大于等于`MAX_PID`或者`last_pid`大于等于`MAX_PID`，将`next_safe`置为`MAX_PID`，扩张区间范围，在后面的遍历中限缩。接下来就遍历进程链表，获取每个进程的已分配的PID：
  - 如果发现有进程的PID等于`last_pid`，则表明冲突，则增加`last_pid`，就是将区间右移一个。这确保了没有一个进程的`pid`与`last_pid`重合；
  - 如果发现一个进程的PID大于`last_pid`且小于`next_safe`，则将这个进程的PID赋值给`next_safe`，即缩小`next_safe`的范围。这能够保证遍历到目前来说`[last_pid,next_safe)`之间没有已用的PID；
  - 如果在遍历中，`last_pid>=next_safe`，需要将`next_safe`扩张到`MAX_PID`，形成新区间并继续在后面的遍历中限缩。
    - 如果在遍历中，`last_pid`还超出了`MAX_PID`，则还需要将`last_pid`重置为1，继续在后面的遍历中限缩区间。

通过以上的处理，能够保证最终`[last_pid,next_safe)`区间范围内为可用PID。返回`last_pid`即为为新进程分配的唯一PID。
## 练习三
### 代码实现
根据文档的提示与说明，我们参考schedule函数里面的禁止和启用中断的过程，编写代码如下：
```c
void proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        local_intr_save(intr_flag);
        {
            current = proc;
            lcr3(next->cr3);
            switch_to(&(prev->context), &(next->context));
        }
        local_intr_restore(intr_flag);
    }
}
```
此函数基本思路是:
- 让 current指向 next内核线程initproc;
- 设置 CR3 寄存器的值为 next 内核线程 initproc 的页目录表起始地址 next->cr3，这实际上是完成进程间的页表切换;
- 由 switch_to函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当switch_to 函数执行完“ret”指令后，就切换到initproc执行了。

值得注意的是，这里我们使用1oca1_intr_save()和1ocal_intr_restore()作用分别是屏蔽中断和打开中断，以免进程切换时其他进程再进行调度，保护进程切换不会被中断。

### 问题解答
在本实验中，创建且运行了2两个内核线程:
- idleproc : 第一个内核进程，完成内核中各个子系统的初始化，之后立即调度，执行其他进程。
- initproc : 用于完成实验的功能而调度的内核进程。


## 扩展练习 Challenge：
>说明语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);是如何实现开关中断的？

### **local_intr_save和 local_intr_restore的函数代码解析**

`local_intr_save(intr_flag)` 和 `local_intr_restore(intr_flag)` 是通过修改**sstatus**寄存器实现中断的保存和恢复。并且通过保存并恢复中断状态，确保在临界区代码执行时中断不会干扰操作，保证数据的一致性。
#### **（一）local_intr_save(intr_flag)**

**函数代码及注释如下：**
```c
#define local_intr_save(x) \
    do {                   \
        x = __intr_save(); \
    } while (0)

static inline bool __intr_save(void) {
        if (read_csr(sstatus) & SSTATUS_SIE) { // 检查是否使能中断
            intr_disable();                    // 禁用中断
            return 1;                          // 返回原来的中断状态为 "使能"
        }
        return 0;                              // 返回原来的中断状态为 "禁用"
    }
```

**local_intr_save函数功能：**
- **调用_intr_save函数保存当前的中断状态并禁用中断。**
   - `local_intr_save` 宏通过调用 `__intr_save()` 来保存中断状态到 `intr_flag`（参数x） 中。它还会禁用中断，从而保护接下来执行的代码，防止它被外部中断打断。

**intr_save函数功能：**
  - **（1）读取中断状态**：
    -  通过 `read_csr(sstatus)` 获取trapframe中的 `sstatus` 寄存器的值，检查全局中断位 `SSTATUS_SIE`来判断当前中断是否使能。
       - `SSTATUS_SIE` 是 Supervisor mode（特权模式）下的中断使能标志
           - `1` 表示中断已启用。
          - `0` 表示中断已禁用。
  - **（2）关闭中断**：
    - 如果中断已启用 (`SSTATUS_SIE == 1`)，则通过 `intr_disable` 清除 `SSTATUS_SIE` 位来禁用中断。因为我们不希望该线程被中断
  - **（3）保存状态**
     - 返回原始中断状态，供后续恢复。即返回 **`1`** 表示中断之前是使能状态；返回 **`0`** 表示中断已经禁用。




#### **(二）local_intr_restore(intr_flag)**

**函数代码及注释如下：**

```c
#define local_intr_restore(x) __intr_restore(x);
static inline void __intr_restore(bool flag) {
        if (flag) { // 如果之前的中断状态是 "使能"
            intr_enable(); // 恢复中断
        }
    }
```

**local_intr_restore函数功能：**
- 恢复中断状态，基于 `intr_flag` 判断中断是否使能。

**intr_restore函数功能：**
  - 根据保存的 `flag` 值决定是否恢复中断：
    - 如果 `flag` 为 `1`，表示之前的中断是启用的，调用 `intr_enable()` 恢复中断。
    - 如果 `flag` 为 `0`，表示之前的中断是禁用的，什么也不做，中断继续保持禁用。
### 语句如何实现开关中断

#### 调用函数简单分析
这两个语句主要在schdule函数中，schedule函数如下所示：
```c
void schedule(void) {
    bool intr_flag;
    list_entry_t *le, *last;
    struct proc_struct *next = NULL;

    local_intr_save(intr_flag); // 保存当前中断状态并禁用中断
    {
        current->need_resched = 0;
        last = (current == idleproc) ? &proc_list : &(current->list_link);
        le = last;
        do {
            if ((le = list_next(le)) != &proc_list) {
                next = le2proc(le, list_link);
                if (next->state == PROC_RUNNABLE) {
                    break;
                }
            }
        } while (le != last);

        if (next == NULL || next->state != PROC_RUNNABLE) {
            next = idleproc;
        }
        next->runs++;
        if (next != current) {
            proc_run(next);
        }
    }
    local_intr_restore(intr_flag); // 恢复之前的中断状态
}
```

**1. 进入调度器临界区**：
   - `local_intr_save(intr_flag)` 被调用：
     - 保存当前中断状态（使能或禁用）到 `intr_flag` 中。
     - 强制禁用中断，保护后续的关键代码区域。
     - 防止调度器执行过程中被其他中断打断，确保调度操作的完整性。

**2. 临界区代码**：
   - 调度器查找下一个可运行的进程 `next`：
     - 遍历进程队列，找到状态为 `PROC_RUNNABLE` 的进程。
     - 如果没有可运行进程，选择 `idleproc`。
     - 执行进程切换。
   - 这些操作涉及修改全局变量 `current` 和其他数据结构，需要避免被中断打断。

 **3. 退出临界区**：
   - `local_intr_restore(intr_flag)` 被调用：
     - 根据 `intr_flag` 的值恢复之前的中断状态。
     - 如果原来中断是启用状态，则重新启用中断。
     - 如果原来中断是禁用状态，保持禁用状态。

#### 实现开关中断的步骤：

- **（1）中断保护**
  -  `local_intr_save` 被用来保存当前的中断状态并禁用中断，这样在调度过程中，当前进程状态的修改不会被打断。
     - 通过 `read_csr(sstatus)` 获取中断位（即`SSTATUS_SIE` 位）状态并存储到 `intr_flag` 中。 
     - 通过 `intr_disable` 清除 `SSTATUS_SIE` 位，确保关键代码段不被中断。
- **（2）恢复中断状态**
  - 调度操作完成后，`local_intr_restore` 被用来恢复中断状态，确保系统恢复到正确的中断使能状态。
    - 根据 `intr_flag` 的值，调用 `intr_enable` 或保持中断禁用。


#### **实现开关中断的目的**

在内核编程中，某些代码段（如调度）需要保证在执行时不被中断打断。使用 `local_intr_save` 和 `local_intr_restore` 来控制中断的启用与禁用，可以确保临界区内的操作原子性。

- **保护临界区**：
  - 临界区是指需要保证原子性执行的代码区域。
    - 例如，在进程调度时，如果中断在选择下一个进程前发生，可能导致调度器的数据结构不一致。
  - `local_intr_save` 和 `local_intr_restore` 确保在关键操作执行时，中断不会打断当前执行的任务。

- **防止中断干扰**：
  - 在执行调度器、内存分配、进程切换等操作时，使用这些函数可以有效防止外部中断影响操作的完整性。通过禁用中断，避免中断处理程序打断正在执行的关键代码。
  - 只有在临界区执行完成后，才恢复中断状态，确保系统在安全的时间点恢复对中断的响应。

- **保持中断的原始状态**：
  - 通过保存中断状态 (`intr_flag`)，可以确保 `local_intr_restore` 恢复时不会误操作。
    - 即如果临界区开始时中断已经禁用，则结束后中断仍保持禁用；如果开始时中断是启用的，则恢复中断状态。

- **保护共享资源**：
  - 如进程队列等全局资源的访问需要原子性操作。


## 实验中的知识点
### 进程与线程的关系
我们平时编写的源代码，经过编译器编译就变成了可执行文件，我们管这一类文件叫做`程序`。而当一个程序被用户或操作系统启动，分配资源，装载进内存开始执行后，它就成为了一个`进程`。

进程与程序之间最大的不同在于`进程是一个“正在运行”的实体`，而`程序只是一个不动的文件`。进程包含程序的内容，也就是它的静态的代码部分，也包括一些在运行时在可以体现出来的信息，比如堆栈，寄存器等数据，这些组成了进程“正在运行"的特性。如果我们只关注于那些“正在运行”的部分，我们就从进程当中剥离出来了线程。

一个进程可以对应一个线程，也可以对应很多线程。这些线程之间往往具有相同的代码，共享一块内存，但是却有不同的CPU执行状态。相比于线程，进程更多的作为一个资源管理的实体(因为操作系统分配网络等资源时往往是基于进程的)，这样线程就作为可以被调度的最小单元，给了调度器更多的调度可能。
### 进程的创建和管理

1. 进程的虚拟内存空间：每个进程有一个完全属于自己的地址空间（实验平台的处理器中有39位地址空间，512G）。这个空间由一个页表（多级页表）描述。每个进程有一个独立的页表，页表中描述了该进程的虚拟地址与该机器的物理地址的对应关系。进程的整个运行过程中，都在使用虚拟地址，应用程序无法触及物理地址，也就无法影响其他进程。
2. 进程的创建
   - 分配一级页表（页目录表）
   - 将一级页表的物理地址放入MMU的相应寄存器中（X86是CR3, RISCV是SATP）
   - 应用程序加载，在虚拟地址中载入分段信息和部分数据、指令
     - 依据编译链接的结果，这些信息放在程序二进制头中
     - 建立虚拟地址与文件内的物理偏移量的对应关系
   - 进程创建完成，将PC转去main以执行程序
   - 取指令数据中引发缺页，OS加载新的数据
     - 如果该虚拟地址的页表不存在，则需创建页表
3. 重要的系统调用：
   - Fork负责创建一个新的进程
     - Fork由父进程调用，创建一个新的进程为子进程
     - 新的进程与原进程共享所有的资源
     - 页表复用，写时复制
     - 新的进程为就绪态等待调度
   - Exec负责让进程执行一个特定的程序
     - Exec由子进程调用，改变其执行的内容
     - 依据二进制文件格式重新建立页表映射
     
### 进程调度
上OS课时候宫老师提到过，调度的代价是很大的，其中一般涉及：
- 减少上下文切换涉及的寄存器数量
- 减少不必要的权限切换

一些理论上可以处理的方式包括：
- 纤程 Fiber, ucontext
- 协程 coroutine
- 发挥ULT快速切换的优势
- 在编程时提出对程序员的限制，要求他们妥善的设计代码
