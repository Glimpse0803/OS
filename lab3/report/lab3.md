# Lab 3 实验报告
## 练习1：理解基于FIFO的页面替换算法
>描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了kern/mm/swap_fifo.c文件中，这点请同学们注意）
>
>至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

我们按照一个页面被换入到被换出的过程来分析函数都做了什么。


**1.do_pg_fault（在vmm.c中）：**

它是用于根据错误地址和错误代码判断访问是否合法从而处理页错误异常的（整个处理缺页异常的开始），如果合法则分配页面或从磁盘加载相应页面到内存中，并建立物理地址与逻辑地址的映射，同时管理页面的可交换性。



**2.find_vma（在vmm.c中，在处理缺页异常的开始被调用，即do_pg_fault）:**

（在处理缺页异常的开始被调用，即do_pg_fault）这个函数用于查找包含产生异常的地址addr的虚拟内存区域（VMA），如果找到则将其缓存至mmap_cache以加速后续查找。  

**3.get_pte（在pmm.c中，在do_pg_fault中被调用）：**

这个函数用于获取指定线性地址la（即产生异常的地址处）的页表项（PTE），并返回其对应的内核虚拟地址；如果页表项不存在（包括一级、二级页目录项）并且create为真，则分配新页面为页表来存储映射关系。

**4.pgdir_alloc_page（在pmm.c中，在do_pg_fault中被调用）：**

它用于分配一个新页面，并将其映射到给定线性地址la（即产生异常的地址处）的页目录pgdir中；如果页面置换功能已初始化，它会将页面标记为可置换。


**5.alloc_page& alloc_pages（在pmm.h & pmm.c中，在get_pte、pgdir_alloc_page中被调用）：**

这两个函数都用于分配页面。其中alloc_page通过调用alloc_pages(1)分配一个页面，而alloc_pages则尝试分配n个页面，并在页面不足且swap功能启用时执行页面交换以释放空间（调用swap_out）。



**6.swap_out（在swap.c中，在alloc_pages中被调用）：**

swap_out函数用于将指定数量（n）的页面从内存换出到磁盘交换区。它选择需要置换的页面，将页面内容写入磁盘后释放内存，并更新页表以反映换出的状态。



**7.swap_out_victim&_fifo_swap_out_victim（在swap.c、swap_fifo.c中，在swap_out中被调用）:**

我们以FIFO页面替换算法为例来讲解swap_out_victim都干了什么。

_fifo_swap_out_victim函数用于选择并移除最近最早插入（FIFO）的页面作为换出页面，并将其地址赋给ptr_page。

**8.swapfs_write（在swapfs.c中，在swap_out中被调用）：**

swapfs_write函数将页面数据写入交换文件系统中的指定位置。调用ide_write_secs函数，将页面内容写入交换设备的目标扇区。

**9.map_swappable&_fifo_map_swappable（在swap.c、swap_fifo.c中，在swap_out中被调用）:**

我们以FIFO页面替换算法为例来讲解map_swappable都干了什么。

fifo_map_swappable函数将页面映射为可交换状态，并将其添加到FIFO（先进先出）页面替换队列中,将页面放置在FIFO链表的尾部，记录了页面的到达顺序，从而在将来实现FIFO页面替换策略。

**10.free_page（在pmm.c中，在swap_out中被调用）:**

free_pages函数用于释放一块连续的内存，大小为n * PAGESIZE，调用pmm_manager的free_pages方法来实现具体的内存释放操作。

**11.tlb_invalidate（在pmm.c中，在swap_out中被调用）:**

tlb_invalidate函数用于刷新TLB，使当前处理器所使用的页表条目无效，确保对页面表的更改被正确反映在处理器的翻译后备缓冲区（TLB）中。该函数通过调用flush_tlb()来清除TLB的所有条目。

**12.swap_in（在swap.c中，在do_pg_fault中被调用）：**

swap_in函数用于将指定虚拟地址（addr）对应的页面从磁盘交换区加载回内存，并将其关联到ptr_result指向的页面结构。


**13.swapfs_read（在swapfs.c中，在swap_in中被调用）：**

swapfs_read函数从交换设备读取指定的交换条目并将其内容存储到给定的页面中(使用`ide_read_secs`函数从交换设备读取数据)。该函数通过读取与交换条目对应的物理地址块，将数据加载回内存。

**14.page_insert（在pmm.c中，在do_pg_fault中被调用）：**

page_insert函数将指定的物理页面插入到页目录中，映射到给定的线性地址，并设置相应的权限。它确保正确处理引用计数和现有页面的替换，同时更新TLB以保持内存访问的有效性。

**15.swap_map_swappable（在swap.c中，在do_pg_fault中被调用）:**

调用map_swappable函数。实现map_swapppable函数的功能。

 **16.assert：**
 
 assert用于检查给定条件是否为真。如果条件为假（即返回值为0），程序会抛出一个错误并终止执行。

  


## 练习3：给未被映射的地址映射上物理页
>  补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。
>
>请在实验报告中简要说明你的设计实现过程。请回答如下问题：
>
>**1.请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。**
>
>**2.如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？**



#### 函数功能

`do_pgfault` 是一个处理缺页异常的函数。它在进程尝试访问未映射的内存地址时被调用。该函数首先检查该地址是否在进程的虚拟内存区域（VMA）中，然后决定是分配新页面、从磁盘加载页面还是返回错误。

#### 代码实现及详细注释

```c
int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
    int ret = -E_INVAL;  // 初始化返回值为无效地址错误
    // 尝试找到包含 addr 的 VMA（虚拟内存区域）
    struct vma_struct *vma = find_vma(mm, addr);

    pgfault_num++;  // 增加缺页错误计数

    // 检查 addr 是否在 mm 的 VMA 范围内
    if (vma == NULL || vma->vm_start > addr) {
        cprintf("not valid addr %x, and can not find it in vma\n", addr); // 地址无效且未找到对应的 VMA
        goto failed; // 跳转到失败处理
    }

    /* 
     * 如果 (写入已存在的地址) 或 
     *    (写入不存在的地址且该地址可写) 或 
     *    (读取不存在的地址且该地址可读) 
     * 则继续处理 
     */
    uint32_t perm = PTE_U; // 默认权限为用户可读
    if (vma->vm_flags & VM_WRITE) { // 检查 VMA 是否可写
        perm |= READ_WRITE; // 如果可写，添加写权限
    }
    addr = ROUNDDOWN(addr, PGSIZE); // 将地址向下对齐到页面大小边界

    ret = -E_NO_MEM; // 初始化返回值为内存不足错误

    pte_t *ptep = NULL;  // 页面表项指针

    // 尝试找到一个 PTE，如果页面表（PT）不存在，则创建一个
    // 注意第三个参数 '1' 表示创建页面表
    if ((ptep = get_pte(mm->pgdir, addr, 1)) == NULL) {
        cprintf("get_pte in do_pgfault failed\n"); // 获取 PTE 失败
        goto failed; // 跳转到失败处理
    }

    if (*ptep == 0) { // 如果物理地址不存在，则分配页面并将逻辑地址映射到物理地址
        if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
            cprintf("pgdir_alloc_page in do_pgfault failed\n"); // 页面分配失败
            goto failed; // 跳转到失败处理
        }
    } else {
        /* LAB3 EXERCISE 3: YOUR CODE
         * 现在我们认为 pte 是一个交换条目
         * 应该从磁盘加载数据并放入物理地址的页面中
         * 并将物理地址与逻辑地址映射，触发交换管理器记录该页面的访问情况
         */
        if (swap_init_ok) { // 检查交换初始化是否成功
            struct Page *page = NULL; // 声明页面指针
            // (1) 根据 mm 和 addr，尝试加载正确的磁盘页面内容
            swap_in(mm, addr, &page); // 从磁盘加载页面内容到内存

            // (2) 根据 mm、addr 和 page，建立物理地址与逻辑地址的映射
            page_insert(mm->pgdir, page, addr, perm); // 将页面插入页表

            // (3) 使页面可交换
            swap_map_swappable(mm, addr, page, 1); // 记录页面为可交换
            page->pra_vaddr = addr; // 设置页面的虚拟地址
        } else {
            cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep); // 如果未初始化交换
            goto failed; // 跳转到失败处理
        }
    }

    ret = 0; // 设置返回值为成功
failed:
    return ret; // 返回结果
}
```
接下来，对我们补充的代码做出注释。


**swap_in函数**

```c
swap_in(mm, addr, &page);
```

- **功能**：`swap_in` 从交换区（磁盘）中读取页面内容并加载到内存中。
- **参数**：
  - `mm`：类型为 `struct mm_struct *`，表示当前进程的内存管理结构，包含了进程的页表 `pgdir` 和 `sm_priv`。`pgdir` 用于定位页面对应的物理地址映射，而 `sm_priv` 是交换管理器私有数据，管理页面换入换出。通过它可以获取进程的页表和相关虚拟内存信息。
  - `addr`：类型为 `uintptr_t`，表示触发缺页异常的虚拟地址。`swap_in` 根据这个地址找到对应的交换条目，并将磁盘上的页面数据加载到物理内存中。
  - `&page`：类型为 `struct Page **`，用于返回加载到内存中的页面对象指针。`swap_in` 中分配了一个物理页面，将数据从磁盘加载到该页面中，然后通过 `&page` 返回。


**page_insert函数**

```c
page_insert(mm->pgdir, page, addr, perm); 

```

- **功能**：`page_insert` 将一个物理页面与指定的虚拟地址进行映射，并设置相应的权限。
- **参数**：
  - `mm->pgdir`：页目录指针，位于 `mm->pgdir` 中。它是页面表的根节点，通过它可以找到并修改与 `la` 对应的页表项，实现虚拟地址和物理地址的映射。
  - `page`：类型为 `struct Page *`，表示将要映射的物理页面结构体。`page_insert` 会将 `page` 映射到虚拟地址 `la`，并在页表项中增加 `page` 的引用计数。
  - `la`：类型为 `uintptr_t`，表示虚拟地址，是页面的逻辑地址。`page_insert` 将页面插入到页表中，使这个虚拟地址与 `page` 所对应的物理地址进行映射。
  - `perm`：类型为 `uint32_t`，表示权限标志。它定义了页面的访问权限（可读、可写、用户模式等），`page_insert` 会根据这些权限设置页表项中的标志位。

**swap_map_swappable函数**

```c
swap_map_swappable(mm, addr, page, 1); 
int swap_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
```

- **功能**：`swap_map_swappable` 将页面标记为“可交换”，即可以在内存和交换区之间进行交换。这个函数一般用于管理页面的访问记录，以便在需要时将其换出。
- **参数**：
  - `mm`：类型为 `struct mm_struct *`，表示当前进程的内存管理结构，包含了进程的页表 `pgdir` 和 `sm_priv`。`pgdir` 用于定位页面对应的物理地址映射，而 `sm_priv` 是交换管理器私有数据，管理页面换入换出。通过它可以获取进程的页表和相关虚拟内存信息。
  - `addr`：类型为 `uintptr_t`，表示页面的虚拟地址。`swap_map_swappable` 使用该地址标记页面 `page` 为可交换，并将其加入交换队列进行管理。
  - `page`：类型为 `struct Page *`，表示要标记为可交换的页面结构。`swap_map_swappable` 会将页面添加到交换管理器的可交换页面队列中，以便进行换入换出管理。
  - `1`：类型为 `int`，用于指定该页面是从交换区换入的，还是新创建的。`swap_in == 1` 表示页面从交换区读取后加载到了内存。



>#### 详细设计实现过程

1. **初始化和VMA查找**:
   - 初始化返回值为无效地址错误，增加缺页错误计数。
   - 调用 `find_vma` 函数检查 `addr` 是否在进程的虚拟内存区域内。如果不在，打印错误信息并跳转到失败处理。

2. **权限设置**:
   - 初始化权限为用户可读，检查 VMA 的标志位，如果是可写，则添加写权限。将地址向下对齐到页面大小边界。

3. **PTE查找**:
   - 调用 `get_pte` 函数尝试找到与 `addr` 相关联的页表项，如果不存在则创建一个。如果无法获取页表项，打印错误信息并跳转到失败处理。

4. **页面分配或交换处理**:
   - 检查 PTE 是否为0，如果是，则表示物理地址不存在，调用 `pgdir_alloc_page` 分配一个新的页面。
   - 如果 PTE 不为0，表示页面已经存在，但可能是一个交换条目。此时检查交换初始化是否成功：
     - 使用 `swap_in` 从磁盘加载页面内容到内存。
     - 使用 `page_insert` 将物理地址与逻辑地址映射。
     - 使用 `swap_map_swappable` 将页面标记为可交换，并设置页面的虚拟地址。


>#### 页目录项和页表项中组成部分对ucore实现页替换算法的潜在用处。

在 uCore 的页替换算法实现中（包括 `swap_in`、`swap_out`、`pgdir_alloc_page` 等函数），页目录项（PDE）和页表项（PTE）中的各组成部分起到了关键作用。它们记录了页面的状态和映射信息，便于管理页面的加载、替换和换出操作。

 **1. 有效位**
   - **作用**：有效位指示页面是否已加载到物理内存中。
   - **用法**：页替换算法通过检查有效位来判断页面是否需要从磁盘换入。在 `do_pgfault` 函数中，通过有效位可以确定是否需要调用 `pgdir_alloc_page` 分配新页面，或调用 `swap_in` 来换入页面。如果某个页面的有效位为 0 且有访问请求时，就会触发缺页异常，从而调用 `swap_in` 函数将该页面从磁盘加载到内存中。如下所示：
   ```c
       if (*ptep == 0) {
        if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
            cprintf("pgdir_alloc_page in do_pgfault failed\n");
            goto failed;
        }
    } 
    else {

        if (swap_init_ok) {
            struct Page *page = NULL;
            swap_in(mm, addr, &page);
            ......}}
  ```

**2.权限位**
   - **作用**：权限位定义了页面的读、写、执行权限。
   - **用法**：权限位用于确保页面在被换入时分配正确的权限。当一个页面被重新加载到内存时，`page_insert` 函数会重新设置 PTE 中的权限位，以保证该页面的访问属性与对应的 VMA 权限相符。此外，在 `do_pgfault` 中，根据 VMA 的 `vm_flags` 来设置页面权限。对于需要写入权限的页面，将 PTE 设置为可写。如下所示：
```c
   ///page_insert:
    *ptep = pte_create(page2ppn(page), PTE_V | perm);
///do_pgfault:
       if (vma->vm_flags & VM_WRITE) {
        perm |= (PTE_R | PTE_W);
    }

```

 **3.物理地址**
   - **作用**：存储页面在物理内存或磁盘中的实际地址。
   - **用法**：在页面被换入内存时，`swap_in` 函数将物理地址存入页表项中，从而建立虚拟地址和物理地址之间的映射关系。`page_insert` 函数使用该地址更新页表项。在 `pgdir_alloc_page` 中调用 `page_insert` 时，物理页框地址被设置在 PTE 中，确保虚拟地址 `la` 可以正确映射到物理页面。如下所示：
```c
///swap_in
 pte_t *ptep = get_pte(mm->pgdir, addr, 0);

///page_insert
pte_t *ptep = get_pte(pgdir, la, 1);

///pgdir_alloc_page

  if (page_insert(pgdir, page, la, perm) != 0) 
```

 **4.换出标记**
   - **作用**：记录页面在磁盘中的位置，用于需要换入的情况。
   - **用法**：当页面被换出时，在 `swap_out` 函数中，`swapfs_write` 将页面写入磁盘并更新页表项的换出标记，确保页面被正确换出，并保留换入所需的信息。换入时，`swap_in` 会根据该位置找到对应的磁盘数据并加载到内存。



>#### 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

1. **捕获新异常**：处理器会捕获新的页访问异常，并更新当前的异常状态。硬件将保存当前的处理器状态，例如程序计数器（PC）和相关的寄存器，以便在处理完异常后恢复。

2. **更新异常状态寄存器**：处理器会将新的异常信息（包括异常地址和异常原因）存储到指定的异常寄存器中。例如，`scause`和`stval`寄存器会分别记录异常原因和访问的虚拟地址。

3. **进入异常处理程序**：处理器根据新的异常类型和优先级跳转到相应的异常处理程序。通常，处理器会从`stvec`寄存器中读取异常处理程序的入口地址，然后跳转到该地址。即trap.c文件中的trap函数。根据异常原因，选择对应的异常处理函数，对于页访问异常应该是用pgfault_handler，再到do_pgfault处理缺页异常。

4. **递归处理缺页异常**：处理器会再次进入缺页异常处理程序。不过这次，操作系统的异常处理程序可能会检查当前的异常嵌套级别，以避免递归导致的栈溢出。若异常嵌套过多，系统可能会触发一个“内核恐慌”（kernel panic）或终止当前进程以保护系统稳定性。

5. **恢复上下文**：如果缺页例程能够成功处理所有缺页异常，它会恢复原始的上下文，并继续执行原来的代码。

>#### 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

有。

`Page` 数据结构用于管理物理内存页帧的状态信息，而页目录项和页表项则用于将虚拟地址映射到实际的物理地址。

`Page` 数组的每一个项（即每一个 `Page` 实例）代表一个物理页帧。当虚拟内存需要映射到物理页时，页表项会指向特定的物理地址，即一个物理页帧。此物理地址可以映射到 `Page` 数组的一个特定项，该项包含了与此物理页帧相关的各种状态信息。因此，页表项的物理地址部分可以间接映射到一个 `Page` 实例，通过页表项的地址可以找到 `Page` 数组中对应的项。

此外，在页表管理的过程中，`Page` 结构体内的 `ref` 反映了当前页帧的引用状态。而在页替换操作中，`pra_page_link`、`flags` 等字段则为替换算法提供了必要的信息。当需要换出页帧时，这些信息会帮助找到合适的页帧，并更新相应的页表项，使之指向新的页帧。


## 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

>如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？


### 好处与优势

1. **查找效率提升**：
   - 一个大页页表意味着直接将虚拟地址映射到物理地址，这样只需一次页表查找，无需多级页表的逐级查询过程。尤其对于较大内存的操作系统而言，可以减少页表的查找时间，从而提升内存访问的性能。

2. **节省内存存储开销**：
   - 在一个大页页表中，由于页表不分层，可以减少多级页表的管理结构开销。当虚拟地址空间较小，且物理内存较大时，单级页表在内存中保存的页表项总数是相对固定的，所以在小规模的嵌入式系统中会显得更加简洁。

3. **简单性**：
   - 一个大页页表管理实现简单，不需要处理复杂的分层结构，方便页表的建立和维护。同时在地址转换逻辑和数据结构上都更加直接，降低了设计与管理的复杂度。
4. **减少TLB缺失**：
   - 由于大页涵盖的物理内存范围更大，TLB中的一个条目可以映射更大的内存范围，从而可能减少TLB缺失的次数。

### 坏处与风险

1. **占用更多内存**：
   - 一个大页页表需为整个虚拟地址空间建立映射表，即使大部分地址未被实际使用，也会占用内存存储完整页表。而分级页表可以按需分配，针对未使用的虚拟地址空间无需分配页表空间，节省了内存资源。

2. **不适合大地址空间**：
   - 在32位或64位系统中， 一个大页页表的大小会随着虚拟地址空间增加而成倍增长。当地址空间非常大时， 一个大页页表所需的内存将变得不切实际或导致内存耗尽，从而无法在现代高容量的内存环境下有效管理内存。

3. **内存碎片化风险**：
   -  一个大页页表通常需要一整块连续的内存用于保存页表内容。随着页表规模的增大，找到合适的连续内存区域变得困难，易导致内存碎片化，影响系统的内存利用率。

4. **缺乏细粒度控制**：
   - 分级页表可以通过不同的层次结构实现更细粒度的内存权限管理，但一个大页页表在这方面的灵活性不足。这可能导致对安全性和权限控制要求较高的系统中无法满足需要，存在潜在的安全风险。

